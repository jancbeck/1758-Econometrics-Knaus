---
title: "Case Study 3 - Group 4"
author:
- Annika Janson h11829506
- Jan Beck h11814291
- Franz Uchatzi
date: "29.11.2020"
output:
  pdf_document: default
  html_document:
    df.print: paged
header-includes: 
 - \usepackage{dcolumn}
 - \renewcommand{\and}{\\}
---


```{r setup, include=FALSE}
library(car)
library(stargazer)
library(xtable)
library(extrafont)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
wages <- read.csv("WD1.csv")
N <- nrow(wages)
```

## 2 Descriptive statistics

```{r, results='asis', echo=FALSE}
stargazer(wages, omit = c("X"), header=FALSE, type='latex', summary.stat=c('mean', 'sd', 'median', 'min', 'max'), title='Summary statistics', align=TRUE)
```
\newpage
### 2.1

The average wage is USD __`r round(mean(wages$wage), 2)`__ and the median wage is USD __`r median(wages$wage)`__.

```{r, echo=FALSE}
hist(wages$wage, main="Histogram of wage", xlab="Wage in USD")
legend("topright", legend=c("Mean","Median"), lwd=c(2,2), col=c("red","blue"))
abline(v = mean(wages$wage), col = "red", lwd = 2)
abline(v = median(wages$wage), col = "blue", lwd = 2)

```

In the histogram we see that the distribution is right-skewed with a few observations exceeding USD 3000. Most observed values are concentrated around an interval of USD Â±500 above and below the mean. Median and mean are fairly close to each other with the median being slightly higher due to the large outliers.

### 2.2

The proportion of workers working more than 40 hours a week is __`r length(which(wages$hours > 40)) / N * 100`%__.

### 2.3

```{r, echo=FALSE}
#cbind(sort(table(wages$educ),decreasing=TRUE)))
```

The most common number of years of education among the workers is __`r as.vector(sort(table(wages$educ), decreasing=TRUE)[1])[1]`__.

### 2.4

No. The most frequent sibling pattern is having __`r names(sort(table(wages$sibs), decreasing=TRUE))[1]`__ sibling.

\newpage
## 3 Data modelling

### 3.1

### 3.2

### 3.3

### 3.4

### 3.5.1

### 3.5.2

### 3.5.3

### 3.5.4

### 3.5.5

### 3.5.6


\newpage

## 4 Simulation Study

### 4.1 

```{r}
set.seed(1)

# our parameters according to spec
N1 <- 10
N2 <- 100
N3 <- 1000
beta0 <- -1
beta1 <- 0.2
mu <- 0
sigma <- sqrt(4)
minX = -3
maxX = 3

# model 1
x1 <- x <- runif(N1, min = minX, max = maxX)
u1 <- rnorm(N1, sd = sigma, mean = mu)
y1 <- beta0 + beta1*x1 + u1
lm1 <- lm(y1 ~ x) # using x instead of x1 to show as one row in stargazer output 

# model 2
x2 <- x <- runif(N2, min = minX, max = maxX)
u2 <- rnorm(N2, sd = sigma, mean = mu)
y2 <- beta0 + beta1*x2 + u2
lm2 <- lm(y2 ~ x) # using x instead of x2 to show as one row in stargazer output

# model 3
x3 <- x <- runif(N3, min = minX, max = maxX)
u3 <- rnorm(N3, sd = sigma, mean = mu)
y3 <- beta0 + beta1*x3 + u3
lm3 <- lm(y3 ~ x) # using x instead of x3 to show as one row in stargazer output

```


```{r, results='asis', echo=FALSE}

invisible(stargazer(lm1, lm2, lm3, header=FALSE, align=TRUE, digits=7, title="Model comparison"))

```




```{r, echo=FALSE}

# This allows three plots to be displayed next to one another
par(mfrow = c(1,3), mar=c(5, 3, 5, 0) + 0.1)

# plot model 1

plot(
  x1, y1, 
  main = bquote(N ~ "=" ~ .(N1)), 
  sub = bquote(hat(beta)[0] ~ "=" ~ .(round(lm1$coef[1], 2)) ~"    " ~ hat(beta)[1] ~ "=" ~ .(round(lm1$coef[2], 2))),
  xlim = c(minX,maxX), ylim = c(-8, 8), 
  col = "gray", 
  xlab = "", ylab = "")
abline(beta0, beta1, lty=2)
abline(lm1)

legend("topright", legend=c("estimated slope","true slope"), lty=c(1,2))

# plot model 2

plot(x2, y2, main = bquote(N ~ "=" ~ .(N2)), sub = bquote(hat(beta)[0] ~ "=" ~ .(round(lm2$coef[1], 2)) ~
                             "    " ~ hat(beta)[1] ~ "=" ~ .(round(lm2$coef[2], 2))),
     xlim = c(minX,maxX), ylim = c(-8, 8), col = "gray", xlab = "", ylab = "")

abline(beta0, beta1, lty=2)
abline(lm2)

legend("topright", legend=c("estimated slope","true slope"), lty=c(1,2))



# plot model 3

plot(x3, y3, main = bquote(N ~ "=" ~ .(N3)), sub = bquote(hat(beta)[0] ~ "=" ~ .(round(lm3$coef[1], 2)) ~
                             "    " ~ hat(beta)[1] ~ "=" ~ .(round(lm3$coef[2], 2))),
     xlim = c(minX,maxX), ylim = c(-8, 8), col = "gray", xlab = "", ylab = "")
abline(beta0, beta1, lty=2)
abline(lm3)

legend("topright", legend=c("estimated slope","true slope"), lty=c(1,2))


```


### 4.2

```{r, echo=FALSE}

alpha <- 0.05

for (i in 1:3) { # iterate over all 3 models
  for (j in 0:1) { # iterate over beta 0 and 1
    # get the standard error of current variable from model
    se <- as.vector(summary(get(paste("lm", i, sep="")))$coefficients[,2][j+1])
    # create variable name
    nam <- paste("beta", j, "ci", i, sep = "")
    # get coef value
    coef <- as.vector(get(paste("lm", i, sep=""))$coef[j+1])
    # calculate left ci boundary
    ciL <- coef - alpha / 2 * se
    # calculate right ci boundary
    ciR <- coef + alpha / 2 * se
    # assign variable 
    assign(nam, c(ciL, ciR))
  }
}

# model 1
beta0se1 <- summary(lm1)$coefficients[,2][1]
beta0ci1 <- c( as.vector(lm1$coef[1]) - (alpha / 2) * beta0se1, as.vector(lm1$coef[1]) + (alpha / 2) * beta0se1 )
beta1se1 <- summary(lm1)$coefficients[,2][2]
beta1ci1 <- c( as.vector(lm1$coef[2]) - (alpha / 2) * beta1se1, as.vector(lm1$coef[2]) + (alpha / 2) * beta1se1 )

# model 2
beta0se2 <- summary(lm2)$coefficients[,2][1]
beta0ci2 <- c( as.vector(lm2$coef[1]) - (alpha / 2) * beta0se2, as.vector(lm2$coef[1]) + (alpha / 2) * beta0se2 )
beta1se2 <- summary(lm2)$coefficients[,2][2]
beta1ci2 <- c( as.vector(lm2$coef[2]) - (alpha / 2) * beta1se2, as.vector(lm2$coef[2]) + (alpha / 2) * beta1se2 )

# model 3
beta0se3 <- summary(lm3)$coefficients[,2][1]
beta0ci3 <- c( as.vector(lm3$coef[1]) - (alpha / 2) * beta0se3, as.vector(lm3$coef[1]) + (alpha / 2) * beta0se3 )
beta1se3 <- summary(lm3)$coefficients[,2][2]
beta1ci3 <- c( as.vector(lm3$coef[2]) - (alpha / 2) * beta1se3, as.vector(lm3$coef[2]) + (alpha / 2) * beta1se3 )

```

### 4.3